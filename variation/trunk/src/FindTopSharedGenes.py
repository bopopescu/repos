#!/usr/bin/env python
"""
Examples:
	#Find top-ranked genes in phenotype 1's results that are shared by at least 10 other phenotypes
	FindTopSharedGenes.py -e 1 -o /tmp/phenotype_1_c10_f200 -c 10 -f 200 -u yh
	
Description:
	2008-09-30 program to find shared top-ranked genes among different phenotypes.
		The initial gene set comes from a specified phenotype.
		For every phenotype, a gene has to appear in >=min_analysis_recurrence results that are generated by different methods.
"""

import sys, os, math
#bit_number = math.log(sys.maxint)/math.log(2)
#if bit_number>40:       #64bit
sys.path.insert(0, os.path.expanduser('~/lib/python'))
sys.path.insert(0, os.path.join(os.path.expanduser('~/script')))

import time, csv, cPickle
import warnings, traceback
from pymodule import PassingData, figureOutDelimiter, getColName2IndexFromHeader, getListOutOfStr
import Stock_250kDB
from sets import Set
from DrawSNPRegion import DrawSNPRegion
import numpy


class RBG_data(object):
	"""
	2008-09-30
	"""
	def __init__(self):
		
		self.gene_id2count = {}
		self.rbg_entry_ls = []
		self.gene_id2rbg_entry_index_ls = {}
	
	def add_rbg_entry_ls(self, rbg_entry_ls):
		"""
		2008-09-30
		"""
		for rbg_entry in rbg_entry_ls:
			rbg_entry_index = len(self.rbg_entry_ls)
			self.rbg_entry_ls.append(rbg_entry)
			gene_id = rbg_entry.gene_id
			if gene_id not in self.gene_id2rbg_entry_index_ls:
				self.gene_id2rbg_entry_index_ls[gene_id] = []
			self.gene_id2rbg_entry_index_ls[rbg_entry.gene_id].append(rbg_entry_index)
			if gene_id not in self.gene_id2count:
				self.gene_id2count[gene_id] = 0
			self.gene_id2count[gene_id] += 1
	
	def retain_genes_above_min_analysis_recurrence(self, min_analysis_recurrence):
		"""
		2008-09-30
		"""
		for gene_id, count in self.gene_id2count.iteritems():
			if count<min_analysis_recurrence:
				del self.gene_id2rbg_entry_index_ls[gene_id]	#discard it
	
	

class FindTopSharedGenes(DrawSNPRegion):
	__doc__ = __doc__
	option_default_dict = {('drivername', 1,):['mysql', 'v', 1, 'which type of database? mysql or postgres', ],\
							('hostname', 1, ): ['papaya.usc.edu', 'z', 1, 'hostname of the db server', ],\
							('dbname', 1, ): ['stock_250k', 'd', 1, 'database name', ],\
							('schema', 0, ): [None, 'k', 1, 'database schema name', ],\
							('db_user', 1, ): [None, 'u', 1, 'database username', ],\
							('db_passwd', 1, ): [None, 'p', 1, 'database password', ],\
							('phenotype_method_id', 1, int): [None, 'e', 1, 'search genes in this phenotype which are shared by lots other phenotypes.'],\
							("min_distance", 1, int): [20000, 'm', 1, 'minimum distance allowed from the SNP to gene'],\
							("get_closest", 0, int): [0, 'g', 0, 'only get genes closest to the SNP within that distance'],\
							('min_MAF', 1, float): [0.1, 'n', 1, 'minimum Minor Allele Frequency.'],\
							('results_directory', 0, ):[None, 't', 1, 'The results directory. Default is None. use the one given by db.'],\
							("output_fname", 1, ): [None, 'o', 1, 'file to store output'],\
							('call_method_id', 0, int):[17, '', 1, 'Restrict results based on this call_method. Default is no such restriction.'],\
							('analysis_method_id', 0, int):[7, 'a', 1, 'Restrict results based on this analysis_method. Default is no such restriction.'],\
							('no_of_top_hits', 1, int): [500, 'f', 1, 'how many number of top hits based on score or -log(pvalue).'],\
							("min_analysis_recurrence", 1, int): [2, '', 1, 'within each phenotype, minimum number of analysis methods that produce this gene'],\
							("min_recurrence", 1, int): [5, '', 1, 'minimum number of phenotypes a gene should show up'],\
							('debug', 0, int):[0, 'b', 0, 'toggle debug mode'],\
							('report', 0, int):[0, 'r', 0, 'toggle report, more verbose stdout/stderr.']}
	def __init__(self,  **keywords):
		"""
		2008-09-30
		"""
		from pymodule import ProcessOptions
		self.ad = ProcessOptions.process_function_arguments(keywords, self.option_default_dict, error_doc=self.__doc__, class_to_have_attr=self)
		
	
	def get_phenotype_method_id2rbg_id_ls(self, call_method_id, min_distance, get_closest):
		"""
		2008-09-30
		"""
		sys.stderr.write("Getting phenotype_method_id2rbg_id_ls ...")
		query = Stock_250kDB.ResultsByGene.query
		query = query.filter(Stock_250kDB.ResultsByGene.results_method.has(call_method_id=call_method_id))
		#query = query.filter(ResultsByGene.results_method.has(phenotype_method_id=phenotype_method_id))
		query = query.filter_by(min_distance=min_distance).filter_by(get_closest=get_closest)
		phenotype_method_id2rbg_id_ls = {}
		counter = 0
		for row in query:
			phenotype_method_id = row.results_method.phenotype_method_id
			if phenotype_method_id not in phenotype_method_id2rbg_id_ls:
				phenotype_method_id2rbg_id_ls[phenotype_method_id] = []
			phenotype_method_id2rbg_id_ls[phenotype_method_id].append(row.id)
			counter += 1
		sys.stderr.write("%s phenotypes, %s results_by_gene. Done.\n"%(len(phenotype_method_id2rbg_id_ls), counter))
		return phenotype_method_id2rbg_id_ls
	
	def get_phenotype_method_id2rbg_data(self, phenotype_method_id2rbg_id_ls, min_analysis_recurrence, no_of_top_hits, results_directory):
		"""
		2008-09-30
		"""
		sys.stderr.write("Getting phenotype_method_id2rbg_data ...\n")
		param_data = PassingData(results_directory=results_directory, no_of_top_lines=no_of_top_hits)
		phenotype_method_id2rbg_data = {}
		for phenotype_method_id, rbg_id_ls in phenotype_method_id2rbg_id_ls.iteritems():
			rbg_data = RBG_data()
			for rbg_id in rbg_id_ls:
				rbg = Stock_250kDB.ResultsByGene.get(rbg_id)
				pdata = self.getTopResultsByGene(rbg, param_data)
				rbg_data.add_rbg_entry_ls(pdata)
			rbg_data.retain_genes_above_min_analysis_recurrence(min_analysis_recurrence)
			phenotype_method_id2rbg_data[phenotype_method_id] = rbg_data
			sys.stderr.write("%s genes for phenotype %s.\n"%(len(rbg_data.gene_id2rbg_entry_index_ls), phenotype_method_id))
		sys.stderr.write("Done")
		return phenotype_method_id2rbg_data
	
	def get_gene_id2phenotype_id_ls(self, phenotype_method_id2rbg_data, main_phenotype_id, min_recurrence):
		"""
		2008-09-30
		"""
		sys.stderr.write("Getting gene_id2phenotype_id_ls ...\n")
		gene_id2phenotype_id_ls = {}
		main_rbg_data = phenotype_method_id2rbg_data.get(main_phenotype_id)
		if main_rbg_data is None:
			return gene_id2no_of_phenotypes
		for gene_id in main_rbg_data.gene_id2rbg_entry_index_ls:
			if gene_id not in gene_id2phenotype_id_ls:
				gene_id2phenotype_id_ls[gene_id] = []
			for phenotype_method_id, rbg_data in phenotype_method_id2rbg_data.iteritems():
				if gene_id in rbg_data.gene_id2rbg_entry_index_ls:
					gene_id2phenotype_id_ls[gene_id].append(phenotype_method_id)
		#remove genes that appear in the number of phenotypes <min_recurrence
		gene_id_ls = gene_id2phenotype_id_ls.keys()
		for gene_id in gene_id_ls:
			no_of_phenotypes = len(gene_id2phenotype_id_ls[gene_id])
			if no_of_phenotypes<min_recurrence:
				del gene_id2phenotype_id_ls[gene_id]
		sys.stderr.write("Done.\n")
		return gene_id2phenotype_id_ls
	
	def outputGenesSNPs(self, phenotype_method_id2rbg_data, gene_id2phenotype_id_ls, snp_info, output_fname):
		"""
		2008-09-30
		"""
		sys.stderr.write("Outputting genes/snps ...")
		writer = csv.writer(open(output_fname, 'w'), delimiter='\t')
		header = ['phenotype_id', 'snps_id', 'chromosome', 'position', 'gene_id', 'score', 'disp_pos', 'no_of_phenotypes']
		writer.writerow(header)
		for gene_id, phenotype_id_ls in gene_id2phenotype_id_ls.iteritems():
			for phenotype_id in phenotype_id_ls:
				rbg_data = phenotype_method_id2rbg_data[phenotype_id]
				for rbg_entry_index in rbg_data.gene_id2rbg_entry_index_ls[gene_id]:
					rbg_entry = rbg_data.rbg_entry_ls[rbg_entry_index]
					chr_pos = snp_info.chr_pos_ls[snp_info.snps_id2index[rbg_entry.snps_id]]
					writer.writerow([phenotype_id, rbg_entry.snps_id, chr_pos[0], chr_pos[1], rbg_entry.gene_id, rbg_entry.score, rbg_entry.disp_pos, len(phenotype_id_ls)])
		del writer
		sys.stderr.write("Done.\n")
					
	def run(self):
		if self.debug:
			import pdb
			pdb.set_trace()
		db = Stock_250kDB.Stock_250kDB(drivername=self.drivername, username=self.db_user,
				   password=self.db_passwd, hostname=self.hostname, database=self.dbname, schema=self.schema)
		db.setup(create_tables=False)
		session = db.session
		snp_info = self.getSNPInfo(db)
		phenotype_method_id2rbg_id_ls = self.get_phenotype_method_id2rbg_id_ls(self.call_method_id, self.min_distance, self.get_closest)
		phenotype_method_id2rbg_data = self.get_phenotype_method_id2rbg_data(phenotype_method_id2rbg_id_ls, self.min_analysis_recurrence, self.no_of_top_hits, self.results_directory)
		gene_id2phenotype_id_ls = self.get_gene_id2phenotype_id_ls(phenotype_method_id2rbg_data, self.phenotype_method_id, self.min_recurrence)
		self.outputGenesSNPs(phenotype_method_id2rbg_data, gene_id2phenotype_id_ls, snp_info, self.output_fname)

if __name__ == '__main__':
	from pymodule import ProcessOptions
	main_class = FindTopSharedGenes
	po = ProcessOptions(sys.argv, main_class.option_default_dict, error_doc=main_class.__doc__)
	
	instance = main_class(**po.long_option2value)
	instance.run()